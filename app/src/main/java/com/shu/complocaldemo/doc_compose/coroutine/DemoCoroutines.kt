package com.shu.complocaldemo.doc_compose.coroutine

object DemoCoroutines {

    val coroutineScopeDemo = """
        37. Сопрограммы и запущенные эффекты в Jetpack Составляют

        При первом запуске приложения Android система выполнения создает один поток, в котором по 
        умолчанию будут работать все компоненты приложения. Этот поток обычно называют основная
         нить Основная роль основного потока заключается в обработке пользовательского интерфейса 
         с точки зрения обработки событий и взаимодействия с представлениями в пользовательском 
         интерфейсе. Любые дополнительные компоненты, запускаемые в приложении, по умолчанию также
          работают в основном потоке.

        Любой код в приложении, выполняющий ресурсоёмкую задачу в основном потоке, приведёт к тому,
         что всё приложение будет зависать до завершения задачи. Обычно это приводит к тому, что 
         операционная система выдаёт пользователю предупреждение «Приложение не отвечает». Это далеко 
         не идеальное поведение для любого приложения. К счастью, Kotlin предоставляет лёгкую 
        альтернативу в виде корутин. В этой главе мы познакомимся с сопрограммами, включая такую
        терминологию, как диспетчеры, область действия сопрограммы, функции приостановки,
        конструкторы сопрограмм и структурированный параллелизм. В этой главе также будет
        рассмотрена связь между сопрограммами на основе каналов и объяснено, как безопасно 
        запускать сопрограммы из составных функций.

        37.1 Что такое сопрограммы?

        Корутины — это блоки кода, которые выполняются асинхронно, не блокируя поток, из которого
         они запущены. Корутины можно реализовать, не беспокоясь о создании сложных многозадачных 
         реализаций или непосредственном управлении несколькими потоками. Благодаря способу реализации
          корутины гораздо эффективнее и требуют меньше ресурсов, чем традиционные многопоточные решения.
           Корутины также упрощают написание, понимание и поддержку кода, поскольку позволяют писать 
           код последовательно, без необходимости писать обратные вызовы для обработки событий и 
           результатов, связанных с потоками.

        Несмотря на то, что корутины появились в Kotlin относительно недавно, в них нет ничего нового
         или инновационного. Корутины в той или иной форме существуют в языках программирования 
         с 1960-х годов и основаны на модели, известной как взаимодействующие последовательные процессы
          (CSP). На самом деле, Kotlin по-прежнему использует многопоточность за кулисами, но делает
           это очень эффективно.

        37.2 Потоки и сопрограммы

        Проблема с потоками заключается в том, что они являются ограниченным ресурсом и требуют 
        больших затрат с точки зрения возможностей процессора и системных издержек. В фоновом режиме
         выполняется большая работа по созданию, планированию и уничтожению потока. Хотя современные
          процессоры могут запускать большое количество потоков, фактическое количество потоков, 
          которые могут выполняться параллельно в любой момент времени, ограничено количеством ядер 
          процессора (хотя новые процессоры имеют 8 и более ядер, в большинстве устройств Android 
          используются процессоры с 4 ядрами). Когда требуется больше потоков, чем имеется ядер 
          процессора, система должна выполнить планирование потоков, чтобы решить, как распределить 
          выполнение этих потоков между доступными ядрами.

        Чтобы избежать этих накладных расходов, вместо того чтобы запускать новый поток для каждой
         корутины, а затем уничтожать его при выходе из корутины, Kotlin поддерживает пул активных 
         потоков и управляет тем, как корутины назначаются этим потокам. Когда активная корутина 
         приостанавливается, она сохраняется средой выполнения Kotlin, а на её место возобновляется 
         другая корутина. Когда корутина возобновляется, она просто восстанавливается в существующем
         незанятом потоке в пуле и продолжает выполняться до тех пор, пока не завершится или не
         будет приостановлена. При использовании этого подхода ограниченное количество потоков 
         эффективно используется для выполнения асинхронных задач с возможностью выполнения 
         большого количества параллельных задач без снижения производительности, которое произошло
         бы при использовании стандартной многопоточности.

        37.3 Область применения сопрограммы

        Все сопрограммы должны выполняться в рамках определённой области видимости, что позволяет 
        управлять ими как группами, а не как отдельными сопрограммами. Это особенно важно при отмене 
        и очистке сопрограмм, а также для того, чтобы сопрограммы не «утекали» (другими словами,
         не продолжали выполняться в фоновом режиме, когда они больше не нужны приложению). Присвоив
          сопрограммам область видимости, можно, например, массово отменять их, когда они больше не
           нужны.

        Kotlin и Android предоставляют несколько встроенных областей видимости, а также возможность 
        создавать собственные области видимости с помощью класса CoroutineScope. Встроенные области 
        видимости можно обобщить следующим образом:

        • GlobalScope — GlobalScope используется для запуска корутин верхнего уровня, которые
         привязаны ко всему жизненному циклу приложения. Поскольку корутины в этой области могут 
         продолжать выполняться, когда они не нужны (например, при выходе из Activity), использование 
         этой области не рекомендуется в приложениях для Android. Корутины, выполняющиеся в GlobalScope,
          считаются использующими неструктурированный параллелизм .

        • ViewModelScope ( Просмотр модели ) — Предоставляется специально для использования в 
        экземплярах ViewModel при использовании компонента ViewModel архитектуры Jetpack. Корутины,
         запущенные в этой области из экземпляра ViewModel, автоматически отменяются системой 
         выполнения Kotlin при уничтожении соответствующего экземпляра ViewModel.

        • Обзор жизненного цикла - С каждым владельцем жизненного цикла связан LifecycleScope.
         Эта область отменяется при уничтожении соответствующего владельца жизненного цикла, 
         что делает её особенно полезной для запуска сопрограмм внутри компонуемых и действий.

        Для большинства задач лучший способ получить доступ к области сопрограммы из составного
         объекта — вызвать Запомнить CoroutineScope() функционируйте следующим образом:

        val CoroutineScope = rememberCoroutineScope()

        CoroutineScope объявляет диспетчер, который будет использоваться для запуска сопрограмм 
        (хотя это можно изменить), и должен указываться при каждом запуске сопрограммы, если она
         должна быть включена в область видимости. Все запущенные сопрограммы в области видимости 
         можно отменить с помощью вызова cancel() метод экземпляра области видимости:

        CoroutineScope.cancel()

        37.4 Приостановить выполнение функций

        Функция приостановки — это особый тип функции Kotlin, которая содержит код сопрограммы. 
        Она объявляется с помощью Kotlin приостановить ключевое слово, которое указывает Kotlin, 
        что функцию можно приостановить и возобновить позже, что позволяет выполнять длительные 
        вычисления без блокировки основного потока.

        Ниже приведен пример функции приостановки:

        приостановить забавную мыслезадачу() {

        // Выполните длительную задачу здесь

        }

        37.5 Диспетчеры сопрограмм

        Kotlin поддерживает потоки для различных типов асинхронной активности, и при запуске
         сопрограммы у вас есть возможность указать конкретный диспетчер из следующих вариантов:

        • Диспетчеры.Главная — Запускает сопрограмму в основном потоке и подходит для сопрограмм,
         которым необходимо вносить изменения в пользовательский интерфейс, а также в качестве 
         универсального варианта для выполнения несложных задач.

        • Диспетчеры.IO — Рекомендуется для сопрограмм, выполняющих операции с сетью, диском или 
        базой данных.

        • Диспетчеры.По умолчанию — Предназначен для ресурсоёмких задач, таких как сортировка данных
         или выполнение сложных вычислений.

        Диспетчер отвечает за назначение сопрограмм соответствующим потокам, а также за приостановление
         и возобновление сопрограмм в течение их жизненного цикла. Например, следующий код запускает
         сопрограмму с помощью диспетчера ввода-вывода:
         
         coroutineScope.launch( Dispatchers.IO ) {
         performSlowTask()
         }
         
         Помимо предустановленных диспетчеров, можно создавать собственные диспетчеры для пулов потоков.
         
         
    """.trimIndent()

    val coroutineBuilders = """
        Построители корутин объединяют все рассмотренные ранее компоненты и запускают корутины,
         чтобы они начали выполняться. Для этого Kotlin предоставляет следующие шесть построителей:

        • launch  — Запускает сопрограмму, не блокируя текущий поток, и не возвращает результат 
        вызывающей стороне. Используйте этот конструктор при вызове приостанавливающей функции 
        из традиционной функции, а также когда результаты сопрограммы не нужно обрабатывать 
        (иногда такие сопрограммы называют «запустил и забыл»).

        • async  – Запускает сопрограмму и позволяет вызывающей стороне ожидать результата 
        с помощью функции await() без блокировки текущего потока. Используйте async, если у 
        вас есть несколько сопрограмм, которые должны выполняться параллельно. Конструктор 
        async можно использовать только внутри другой приостанавливающей функции.

        • withContext – Это позволяет запускать сопрограмму в контексте, отличном от контекста, 
        используемого родительской сопрограммой. Например, сопрограмма, работающая в контексте Main,
        может запустить дочернюю сопрограмму в контексте Default с помощью этого построителя.
        Построитель withContext также предоставляет полезную альтернативу async при возврате
        результатов из сопрограммы.

        • coroutineScope  – Конструктор coroutineScope идеально подходит для ситуаций, когда функция
         приостановки запускает несколько сопрограмм, которые будут выполняться параллельно,
          и когда какое-то действие должно произойти только после завершения всех сопрограмм. 
          Если эти сопрограммы запускаются с помощью конструктора coroutineScope, вызывающая функция 
          не вернется, пока не завершатся все дочерние сопрограммы. При использовании coroutineScope
           сбой в любой из сопрограмм приведет к отмене всех остальных сопрограмм.

        • supervisorScope — Аналогично coroutineScope, описанному выше, за исключением того, 
        что сбой в одной дочерней задаче не приводит к отмене других задач.

        • runBlocking - Запускает сопрограмму и блокирует текущий поток до завершения сопрограммы.
         Обычно это противоположно тому, что требуется от сопрограмм, но полезно для тестирования
          кода и интеграции устаревшего кода и библиотек. В противном случае этого следует избегать.
    """.trimIndent()

    val jobs = """
        Каждый вызов конструктора корутины, например launch или async, возвращает экземпляр Job, 
        который, в свою очередь, можно использовать для отслеживания и управления жизненным циклом 
        соответствующей корутины. Последующие вызовы конструктора из корутины создают новые 
        экземпляры Job, которые становятся дочерними по отношению к непосредственному родительскому
        экземпляру Job, формируя дерево отношений «родитель-потомок», где отмена родительского
        экземпляра Job рекурсивно отменяет все его дочерние экземпляры.
        Однако отмена дочернего процесса не отменяет родительский, хотя необработанное исключение в
         дочернем процессе, созданном с помощью конструктора запуска, может привести к отмене
          родительского процесса (это не относится к дочерним процессам, созданным с помощью 
          асинхронного конструктора, который инкапсулирует исключение в возвращаемый родительскому 
          процессу результат).

        Статус сопрограммы можно определить, обратившись к свойствам isActive, isCompleted и
         isCancelled связанного с ней объекта Job. Помимо этих свойств, в экземпляре Job также
          доступно несколько методов. Например, Job и все его дочерние элементы можно отменить, 
          вызвав cancel() метод объекта Job, в то время как вызов cancelChildren() метод отменит все дочерние сопрограммы.

        В  join() метод можно вызвать для приостановки сопрограммы, связанной с заданием, до 
        завершения всех дочерних заданий. Чтобы выполнить эту задачу и отменить задание после
         завершения всех дочерних заданий, просто вызовите cancelAndJoin() метод.

        Эта иерархическая структура заданий вместе с областями сопрограмм образует основу
         структурированного параллелизма, цель которого — гарантировать, что сопрограммы не
          будут выполняться дольше, чем необходимо, без необходимости вручную сохранять ссылки
         на каждую сопрограмму.
    """.trimIndent()

    val channels = """
        Каналы предоставляют простой способ реализации взаимодействия между сопрограммами, 
       включая потоки данных. В простейшей форме это предполагает создание экземпляра канала
       и вызов send() метод для отправки данных. После отправки переданные данные могут 
       быть получены в другой сопрограмме с помощью вызова receive() метод того же экземпляра канала.

        Следующий код, например, передаёт шесть целых чисел из одной сопрограммы в другую:
        
        
    """.trimIndent()


    val sideEffects = """
        В этой главе мы рассмотрели корутины и объяснили, как использовать область корутины для 
        асинхронного выполнения кода. В каждом случае корутина запускалась из обработчика событий 
        onClick компонента Button. Причина в том, что хотя корутину можно запустить таким образом
        из области обработчика событий, это небезопасно делать из области родительского компонента.
        Рассмотрим, например, следующий код:
        
        @Composable
        fun Greeting(name: String) {
            val coroutineScope = rememberCoroutineScope()
            coroutineScope.launch() {
                performSlowTask()
            }
        }
        
        Попытка скомпилировать приведённый выше код приведёт к ошибке, которая выглядит следующим образом:

        Вызовы для запуска должны происходить внутри LaunchedEffect, а не композиции
        
        При работе в рамках компонуемого объекта запуск сопрограмм таким образом невозможен, 
        поскольку это может привести к неблагоприятным побочным эффектам. В контексте Jetpack Compose 
        побочный эффект возникает, когда асинхронный код вносит изменения в состояние компонуемого 
        объекта из другой области видимости, не принимая во внимание жизненный цикл этого компонуемого
        объекта. Риск заключается в том, что сопрограмма может продолжить работу после выхода из
        компонуемого объекта, что является особой проблемой, если сопрограмма все еще выполняется и
        вносит изменения в состояние при следующем запуске компонуемого объекта.

        Чтобы избежать этой проблемы, нам нужно запускать наши сопрограммы из тела компонуемого элемента 
        LaunchedEffect или SideEffect. В отличие от приведенной выше попытки напрямую запустить сопрограмму
        из области действия компонуемого элемента, эти два компонуемых элемента считаются безопасными для
        запуска сопрограмм, поскольку они осведомлены о жизненном цикле родительского компонуемого элемента.

        При вызове компонуемого элемента LaunchedEffect, содержащего код запуска сопрограммы, сопрограмма 
        немедленно запускается и начинает выполнять асинхронный код. Как только родительский компонуемый
        элемент завершает работу, экземпляр LaunchedEffect и сопрограмма уничтожаются.
        
        
    """.trimIndent()

    val launchEffect = """
        Синтаксис для объявления LaunchedEffect, содержащего сопрограмму, выглядит следующим образом:
        
        LaunchedEffect(key1, key2, ...) {
            coroutineScope.launch() {
            // async code here
            }
        }
        
        В key Значения параметров (из которых хотя бы одно должно быть) управляют поведением
         сопрограммы посредством перекомпоновки. Пока значения любых ключевых параметров остаются 
         неизменными, LaunchedEffect будет поддерживать работу одной и той же сопрограммы при 
         многократной перекомпоновке родительского компонента. Однако если ключевое значение 
         изменится, LaunchedEffect отменит текущую сопрограмму и запустит новую.

        Чтобы вызвать нашу функцию приостановки из нашего компонента, нам нужно изменить код следующим образом:
        
        @Composable
        fun Greeting(name: String) {
            val coroutineScope = rememberCoroutineScope()
            LaunchedEffect(key1 = Unit) {
                coroutineScope.launch() {
                    performSlowTask()
                }
            }
        }
        
        Обратите внимание, что в приведённом выше примере в качестве ключа мы передали экземпляр Unit
        (эквивалент значения void), чтобы указать, что сопрограмму не нужно воссоздавать с помощью перекомпоновки.

        Помимо LaunchedEffect, Jetpack Compose также включает в себя компонуемый элемент SideEffect.
        В отличие от LaunchedEffect, сопрограмма SideEffect выполняется после завершения компоновки 
        родительского элемента. SideEffect также не принимает ключевые параметры и перезапускается
        при каждой повторной компоновке родительского элемента.
        
        
    """.trimIndent()
}