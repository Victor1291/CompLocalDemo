package com.shu.complocaldemo.doc_compose

object BookCompose {

    val guidelines = """
        Рекомендации по компоновке в ConstraintLayout обеспечивают горизонтальную или вертикальную опорную линию, 
        относительно которой можно располагать компоненты. Это особенно полезно, когда группу компонентов нужно 
        выровнять относительно определенной линии оси. Положение рекомендации можно задать в процентах от высоты 
        или ширины родительского элемента или с определенным смещением от стороны. Например, следующее правило 
        создаёт направляющую, которая параллельна начальному краю родительского элемента 
        (другими словами, вертикальную линию) и расположена на 25% от ширины родительского элемента:
        
        createGuidelineFromBottom(offset = 60.dp)
        
        Аналогичным образом следующий вызов функции создаёт горизонтальную линию,
        расположенную на 60dp выше нижнего края родительского элемента:
        
        
        createGuidelineFromBottom(offset = 60.dp)
        
        
        
    """.trimIndent()

    val barriers = """
        
        Барьеры ConstraintLayout создаются относительно определённой стороны одного или 
        нескольких компонентов с помощью следующих функций:
        
        • createStartBarrier()
        • createEndBarrier()
        • createTopBarrier()
        • createBottomBarrier()
        
        В каждую функцию передаётся список компонентов, которым должен быть назначен барьер,
        а также необязательный запас, и возвращается ссылка на барьер, к которому могут
        быть привязаны другие компоненты, например:
        
        val barrier = createEndBarrier(button1, button2, margin = 30.dp)
        
        Приведенное выше утверждение создаст вертикальный барьер (начальный и конечный барьеры
        являются вертикальными, а верхний и нижний — горизонтальными), расположенный на расстоянии
        30dp от конца кнопки 1 и кнопки 2. Если кнопки 1 и 2 имеют разную ширину,
        барьер будет располагаться на расстоянии 30dp от конца самого широкого компонента 
        в любой момент времени.
        
        
        Размер компонента button3 должен быть таким, чтобы он занимал максимально доступное
        пространство, разрешённое его ограничениями. Это не только обеспечит заполнение кнопки 
        по доступной высоте, но и позволит регулировать ширину в зависимости от изменений размера 
        кнопок button1 и button2. Для этого необходимо изменить ограничения по ширине и высоте
        компонента button3 на Заполняющие ограничения . Измените объявление button3,
        чтобы добавить эти ограничения измерения следующим образом: смотри в коде
        
        Далее нам нужно проверить, обеспечивает ли макет требуемое поведение, 
        увеличив ширину кнопки 1 следующим образом:
        
        MyButton(text = "Button1", Modifier.width( 150 .dp).constrainAs(button1) {
        
        Теперь верните ширину кнопки 1 к 100dp, затем увеличьте ширину кнопки 2 до 150dp.
        На этот раз ширина кнопки 3 не уменьшилась, что привело к наложению на кнопку 2:
        
        Очевидно, что это не соответствует нашим требованиям к макету. Это происходит потому,
        что кнопка 3 ограничена только кнопкой 1 и не реагирует на изменения в кнопке 2. 
        Чтобы устранить этот недостаток, нам нужно создать барьер, расположенный в конце 
        кнопок 1 и 2. Вместо того чтобы ограничивать начальный край кнопки 3 концом кнопки 1,
        мы будем ограничивать начало кнопки барьером:
        
        При внесении этих изменений кнопка 3 будет изменять размер независимо от того,
        увеличивается ли ширина кнопки 1 или кнопки 2. При изменении ширины барьер,
        к которому привязана кнопка 3, будет пропорционально перемещаться, 
        тем самым уменьшая ширину кнопки 3:
        
    """.trimIndent()

    val constraintSets = """
        До сих пор в этой главе все ограничения объявлялись в модификаторах, применяемых к 
        отдельным компонентам. Compose также позволяет объявлять ограничения отдельно в 
        виде наборы ограничений . Эти несвязанные ограничения Затем его можно передать в 
        ConstraintLayout и применить к compose child.

        Разделенные ограничения позволяют создавать наборы ограничений, которые можно
        использовать повторно без необходимости дублировать объявления модификаторов. 
        Эти наборы ограничений также обеспечивают гибкость в передаче различных наборов
        ограничений в зависимости от других критериев. Например, макет может использовать
        различные наборы ограничений в зависимости от размера экрана или ориентации устройства.
        
        Приведенный выше код объявляет новую функцию, которая принимает значение маржи и 
        возвращает объект ConstraintSet. Затем выполняется вызов функции createRefFor() 
        функция для создания ссылки на любой объект, к которому применяется набор ограничений.
        Затем набор ограничений создается путем вызова сдерживать() функция, 
        проходящая через ссылку и объявляющая ограничения в завершающем лямбда-выражении.

        Создав набор ограничений, его можно передать в ConstraintLayout и применить к button1.
        Для этого нужно создать экземпляр набора ограничений, передать его в экземпляр 
        ConstraintLayout и использовать макет() функция-модификатор для связывания ссылки 
        на набор ограничений с компонентом button1. Измените функцию MainScreen, 
        чтобы применить эти изменения:
        
        
    """.trimIndent()

    val intrinsicsDemo = """
        Как мы уже знаем из предыдущих глав, один из способов, с помощью которого Compose 
        может быстро и эффективно отображать макеты пользовательского интерфейса, заключается
        в том, что каждый компонуемый элемент измеряется только один раз во время операции 
        перекомпоновки. Однако иногда возникают ситуации, когда родительскому компонуемому 
        элементу необходимо знать информацию о размерах дочерних элементов до их измерения
        в рамках перекомпоновки. Например, вам может понадобиться, чтобы ширина столбца
        соответствовала ширине самого широкого дочернего элемента. Хотя родители не могут
        измерять своих детей, информацию о размерах можно получить, не нарушая правило 
        «измерять один раз», с помощью  intrinsic measurements.
        
        Родительский составной файл может получить информацию о размерах своих дочерних элементов,
        обратившись к Макс . и Мин значения перечисления Compose IntrinsicSize. 
        IntrinsicSize предоставляет родителю информацию о максимально или минимально возможной
        ширине или высоте самого широкого или высокого дочернего элемента. Это позволяет родителю 
        принимать решения о размере на основе потребностей дочерних элементов. Например, следующий
        код устанавливает высоту элемента Row на основе информации о внутреннем размере:
        
        Row(modifier = modifier.height(IntrinsicSize.Min)) {
        }
        
        При отображении этого компонента высота строки будет установлена на минимально возможную высоту,
        необходимую для отображения самого высокого дочернего элемента. Аналогичным образом следующий
        код устанавливает ширину столбца на максимально возможную ширину самого широкого дочернего элемента:
        
        Column(modifier = modifier.width(IntrinsicSize.Max)) {
        }
        
        При отсутствии модификаторов, указывающих на обратное, компонуемый элемент, такой
        как строка или столбец, обычно занимает всё пространство, доступное для него в 
        родительском элементе. С помощью IntrinsicSize эти компонуемые элементы можно настроить 
        так, чтобы они соответствовали пространственным требованиям своих дочерних элементов.
        Как мы увидим в следующем примере, это становится особенно полезным, когда один или
        несколько дочерних элементов подвержены динамическим изменениям размера.
        
        
     
    """.trimIndent()

    val maxVsMin = """
        
        Максимальное значение по сравнению с минимальным. Внутренние размеры

        Перечисление IntrinsicSize предоставляет доступ как к максимальным, так и к минимальным размерам.
        Разница между этими двумя значениями требует пояснения. Всем видимым компонуемым элементам
        требуется место на дисплее устройства для отображения их содержимого, и многие из них могут 
        адаптироваться к изменениям в количестве доступного пространства. Эту концепцию, пожалуй, 
        лучше всего можно описать на примере компонуемого элемента Text. Текстовый элемент, отображающий
        одну строку текста, имеет максимальную ширину, равную длине отображаемого текста.
        Это соответствует IntrinsicSizeМакс . значение:

        Чтобы максимально увеличить скорость рендеринга, Compose запрещает измерять компонуемый 
        элемент более одного раза во время перекомпоновки. Это может быть проблематично, если 
        родительскому элементу нужно принять решение о размере до того, как будут измерены дочерние
        элементы. У всех компонуемых элементов есть минимальный и максимальный размер, при котором 
        они могут комфортно рендерить содержимое без отсечения или затемнения. IntrinsicSize позволяет 
        родителю сканировать своих дочерних элементов и определять минимальную и максимальную высоту
        и ширину самого широкого и высокого дочернего элемента, а также использовать эту информацию
        для настройки собственных размеров.
        
    """.trimIndent()


}